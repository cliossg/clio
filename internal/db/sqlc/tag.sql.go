// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tag.sql

package sqlc

import (
	"context"
	"database/sql"
)

const addTagToContent = `-- name: AddTagToContent :exec
INSERT INTO content_tag (id, content_id, tag_id, created_at)
VALUES (?, ?, ?, ?)
`

type AddTagToContentParams struct {
	ID        string       `json:"id"`
	ContentID string       `json:"content_id"`
	TagID     string       `json:"tag_id"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) AddTagToContent(ctx context.Context, arg AddTagToContentParams) error {
	_, err := q.db.ExecContext(ctx, addTagToContent,
		arg.ID,
		arg.ContentID,
		arg.TagID,
		arg.CreatedAt,
	)
	return err
}

const createTag = `-- name: CreateTag :one
INSERT INTO tag (id, site_id, short_id, name, slug, created_by, updated_by, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, site_id, short_id, name, slug, created_by, updated_by, created_at, updated_at
`

type CreateTagParams struct {
	ID        string         `json:"id"`
	SiteID    string         `json:"site_id"`
	ShortID   sql.NullString `json:"short_id"`
	Name      string         `json:"name"`
	Slug      string         `json:"slug"`
	CreatedBy sql.NullString `json:"created_by"`
	UpdatedBy sql.NullString `json:"updated_by"`
	CreatedAt sql.NullTime   `json:"created_at"`
	UpdatedAt sql.NullTime   `json:"updated_at"`
}

func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, createTag,
		arg.ID,
		arg.SiteID,
		arg.ShortID,
		arg.Name,
		arg.Slug,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.SiteID,
		&i.ShortID,
		&i.Name,
		&i.Slug,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tag WHERE id = ?
`

func (q *Queries) DeleteTag(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTag, id)
	return err
}

const getContentForTag = `-- name: GetContentForTag :many
SELECT c.id, c.site_id, c.user_id, c.short_id, c.section_id, c.kind, c.heading, c.summary, c.body, c.draft, c.featured, c.series, c.series_order, c.published_at, c.created_by, c.updated_by, c.created_at, c.updated_at, c.contributor_id, c.contributor_handle, c.author_username, c.hero_title_dark, c.images_meta FROM content c
JOIN content_tag ct ON c.id = ct.content_id
WHERE ct.tag_id = ?
ORDER BY c.created_at DESC
`

func (q *Queries) GetContentForTag(ctx context.Context, tagID string) ([]Content, error) {
	rows, err := q.db.QueryContext(ctx, getContentForTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Content
	for rows.Next() {
		var i Content
		if err := rows.Scan(
			&i.ID,
			&i.SiteID,
			&i.UserID,
			&i.ShortID,
			&i.SectionID,
			&i.Kind,
			&i.Heading,
			&i.Summary,
			&i.Body,
			&i.Draft,
			&i.Featured,
			&i.Series,
			&i.SeriesOrder,
			&i.PublishedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContributorID,
			&i.ContributorHandle,
			&i.AuthorUsername,
			&i.HeroTitleDark,
			&i.ImagesMeta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTag = `-- name: GetTag :one
SELECT id, site_id, short_id, name, slug, created_by, updated_by, created_at, updated_at FROM tag WHERE id = ?
`

func (q *Queries) GetTag(ctx context.Context, id string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTag, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.SiteID,
		&i.ShortID,
		&i.Name,
		&i.Slug,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTagByName = `-- name: GetTagByName :one
SELECT id, site_id, short_id, name, slug, created_by, updated_by, created_at, updated_at FROM tag WHERE site_id = ? AND name = ?
`

type GetTagByNameParams struct {
	SiteID string `json:"site_id"`
	Name   string `json:"name"`
}

func (q *Queries) GetTagByName(ctx context.Context, arg GetTagByNameParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTagByName, arg.SiteID, arg.Name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.SiteID,
		&i.ShortID,
		&i.Name,
		&i.Slug,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTagBySlug = `-- name: GetTagBySlug :one
SELECT id, site_id, short_id, name, slug, created_by, updated_by, created_at, updated_at FROM tag WHERE site_id = ? AND slug = ?
`

type GetTagBySlugParams struct {
	SiteID string `json:"site_id"`
	Slug   string `json:"slug"`
}

func (q *Queries) GetTagBySlug(ctx context.Context, arg GetTagBySlugParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTagBySlug, arg.SiteID, arg.Slug)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.SiteID,
		&i.ShortID,
		&i.Name,
		&i.Slug,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTagsBySiteID = `-- name: GetTagsBySiteID :many
SELECT id, site_id, short_id, name, slug, created_by, updated_by, created_at, updated_at FROM tag WHERE site_id = ? ORDER BY name
`

func (q *Queries) GetTagsBySiteID(ctx context.Context, siteID string) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getTagsBySiteID, siteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.SiteID,
			&i.ShortID,
			&i.Name,
			&i.Slug,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForContent = `-- name: GetTagsForContent :many
SELECT t.id, t.site_id, t.short_id, t.name, t.slug, t.created_by, t.updated_by, t.created_at, t.updated_at FROM tag t
JOIN content_tag ct ON t.id = ct.tag_id
WHERE ct.content_id = ?
ORDER BY t.name
`

func (q *Queries) GetTagsForContent(ctx context.Context, contentID string) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getTagsForContent, contentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.SiteID,
			&i.ShortID,
			&i.Name,
			&i.Slug,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllTagsFromContent = `-- name: RemoveAllTagsFromContent :exec
DELETE FROM content_tag WHERE content_id = ?
`

func (q *Queries) RemoveAllTagsFromContent(ctx context.Context, contentID string) error {
	_, err := q.db.ExecContext(ctx, removeAllTagsFromContent, contentID)
	return err
}

const removeTagFromContent = `-- name: RemoveTagFromContent :exec
DELETE FROM content_tag WHERE content_id = ? AND tag_id = ?
`

type RemoveTagFromContentParams struct {
	ContentID string `json:"content_id"`
	TagID     string `json:"tag_id"`
}

func (q *Queries) RemoveTagFromContent(ctx context.Context, arg RemoveTagFromContentParams) error {
	_, err := q.db.ExecContext(ctx, removeTagFromContent, arg.ContentID, arg.TagID)
	return err
}

const updateTag = `-- name: UpdateTag :one
UPDATE tag SET
    name = ?,
    slug = ?,
    updated_by = ?,
    updated_at = ?
WHERE id = ?
RETURNING id, site_id, short_id, name, slug, created_by, updated_by, created_at, updated_at
`

type UpdateTagParams struct {
	Name      string         `json:"name"`
	Slug      string         `json:"slug"`
	UpdatedBy sql.NullString `json:"updated_by"`
	UpdatedAt sql.NullTime   `json:"updated_at"`
	ID        string         `json:"id"`
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, updateTag,
		arg.Name,
		arg.Slug,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.SiteID,
		&i.ShortID,
		&i.Name,
		&i.Slug,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
